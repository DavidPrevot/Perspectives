<html>
<head>
<link rel="SHORTCUT ICON" href="../plugin/chrome/content/default.png">
<title>Perspectives - Test cases</title>

<script type="text/javascript" src="../plugin/chrome/content/common.js"></script> 
<script type="text/javascript" src="../plugin/chrome/content/client_policy.js"></script>
<script type="text/javascript" src="../plugin/chrome/content/notaries.js"></script>
<script type="text/javascript"> 

d_print_all = true;
other_cache = { "debug" : "" }; // needed for common.js

var g_test_count = 0;
var g_pass_count = 0;
var g_fail_count = 0;

function clear() { 
   var node = document.getElementById('results'); 
   node.innerHTML = "";
   g_test_count = 0;
   g_pass_count = 0;
   g_fail_count = 0;
}

function write_string(str) {
   write_string_to_element(str, 'p');
} 

function write_string_to_element(str, elname) {
   var node = document.getElementById('results');
   var child = document.createElement(elname);
   child.innerHTML = str;
   node.appendChild(child);
}

function assert(test, case_name) {
  g_test_count++;
	if(test) {
	  write_string_to_element("[" + g_test_count +
      "] <font color='green'>passed</font> : " + case_name, 'li');
    g_pass_count++;
  }
  else {
	  write_string_to_element("[" + g_test_count +
      "] <b><font color='red'>FAILED</font></b> : " + case_name, 'li');
    g_fail_count++;
  }

  // if people are looking through the console to debug,
  // give them some help tracing the action.
  if (window.console != undefined) {
        console.log("------- Finished test " +
          g_test_count + ": " + case_name);
  }
} 

function quorum_basics() {
 write_string("Starting basic quorum tests...");


 var key = "bc:7f:b1:15:25:4e:7b:fb:93:83:ac:5c:26:df:f7:00";
 var key2 = "bd:7f:b1:15:25:4e:7b:fb:93:83:ac:5c:26:df:f7:00";
 var cur_time = 10000;
 var max_stale_sec = 200;

 var key_start_diff = 1000;
 var key_start_time = (cur_time - key_start_diff);

 var server_result_list = [ 
   { "server" : "204.255.124.41:8080", 
     "obs" : [  { "key" : key,
		  "timestamps" : [ { "start" : 0 , "end" : cur_time  } ] } ]
   }, 
   { "server" : "128.2.185.85:8080",
     "obs" : [  { "key" : key,
		  "timestamps" : [ { "start" : key_start_time , "end" : cur_time  } ] } ]
   } 
 ];



 var quorum_duration = 0;


 quorum_duration = Pers_client_policy.get_quorum_duration(key,
          server_result_list,	2, max_stale_sec,cur_time);
 assert((quorum_duration == (cur_time - key_start_time) + 1), "Requiring larger quorum gives a shorter duration");


 quorum_duration = Pers_client_policy.get_quorum_duration(key,
          server_result_list, 1, max_stale_sec, cur_time);
 assert((quorum_duration == cur_time + 1), "Requiring smaller quorum gives a longer duration");
 assert((quorum_duration > (cur_time - max_stale_sec)), "Getting enough quorum voters passes");


 quorum_duration = Pers_client_policy.get_quorum_duration(key,
          server_result_list, 10, max_stale_sec, cur_time);
 assert((quorum_duration == -1), "Getting fewer quorum voters than required fails");


 quorum_duration = Pers_client_policy.get_quorum_duration(key,
          server_result_list,	1, max_stale_sec,
				cur_time + max_stale_sec);
 assert((quorum_duration == (cur_time + max_stale_sec) + 1), "Being at the edge of the quorum duration time limit passes");


 quorum_duration = Pers_client_policy.get_quorum_duration(key,
          server_result_list, 1, max_stale_sec,
        cur_time + max_stale_sec + 1);
 assert((quorum_duration == -1), "Being over the quorum duration time limit fails");


 quorum_duration = Pers_client_policy.get_quorum_duration(key2,
          server_result_list, 1, max_stale_sec,cur_time);
 assert((quorum_duration == -1), "Looking for a key that has no results fails");


 var empty_result_list = [];

 quorum_duration = Pers_client_policy.get_quorum_duration(key,
          empty_result_list, 1, max_stale_sec,cur_time);
 assert((quorum_duration == -1), "Passing an empty results list fails");



 write_string("Finished");
} 


// Test cases: we pass the quorum percentage, but the key is really old.
// Originally this was found because get_quorum_duration() was passing
// parameters to oldest_most_recent() in the wrong order,
// making certain valid keys show up as not trusted.

function quorum_oldkey() {

 var keybc = "bc:7f:b1:15:25:4e:7b:fb:93:83:ac:5c:26:df:f7:00"; //the key we're looking for
 var keybd = "bd:7f:b1:15:25:4e:7b:fb:93:83:ac:5c:26:df:f7:00";

 var cur_time = 200 * 24 * 3600; //i.e. 200 days since epoch
 var max_stale_sec = 2 * 24 * 3600; // 2 days
 var q_required = 1;
 var q_duration_required = 100 * 24 * 3600 ;

 var foundkey_start = 100;


 // see testcase description inside assert() calls, below, for explanations
 // of array contents.
 var results_oldkey = [
   { "server" : "128.2.185.85:8080",
     "obs" : [  {"key" : keybc,
      "timestamps" : [ { "start" : foundkey_start * 24 * 3600, "end" : (foundkey_start + q_duration_required) * 24 * 3600  } ] },
      ]
   }
 ];


 var results_oldkey_notpushed = [
   { "server" : "128.2.185.85:8080",
     "obs" : [  {"key" : keybc,
      "timestamps" : [ { "start" : foundkey_start * 24 * 3600, "end" : (foundkey_start + q_duration_required) * 24 * 3600  } ] },
      ]
   },
   { "server" : "204.255.124.41:8080",
     "obs" : [  { "key" : keybd,
     // start date of 10 is arbitrary
      "timestamps" : [ { "start" : 10 * 24 * 3600 , "end" : foundkey_start * 24 * 3600  } ] },
      ]
   }
 ];

 // almost the same keys as above, except the unrelated key's time range ends 1 days earlier
 var results_oldkey_pushedout = [
   { "server" : "204.255.124.41:8080",
     "obs" : [  { "key" : keybd,
      "timestamps" : [ { "start" : 10 * 24 * 3600 , "end" : (foundkey_start - 1 ) * 24 * 3600  } ] },
      ]
   },
   { "server" : "128.2.185.85:8080",
     "obs" : [
      {"key" : keybc,
      "timestamps" : [ { "start" : foundkey_start * 24 * 3600, "end" : (foundkey_start + q_duration_required) * 24 * 3600  } ] },
      ]
   }
 ];


 write_string("Starting oldkey quorum tests...");
 var quorum_duration = 0;


 quorum_duration = Pers_client_policy.get_quorum_duration(keybc, results_oldkey,
          q_required, max_stale_sec, cur_time);
 assert((quorum_duration >= q_duration_required),
  "1) Old key within duration accepted");


 quorum_duration = Pers_client_policy.get_quorum_duration(keybc, results_oldkey,
          q_required, max_stale_sec, cur_time);
 assert((quorum_duration <= (q_duration_required * 2)),
  "2) Old key outside duration rejected");


 quorum_duration = Pers_client_policy.get_quorum_duration(keybc, results_oldkey_notpushed,
          q_required, max_stale_sec, cur_time);
 assert((quorum_duration > q_duration_required),
  "3) Same as (1), but an unrelated key result ends on day target key begins");


 quorum_duration = Pers_client_policy.get_quorum_duration(keybc, results_oldkey_pushedout,
          q_required, max_stale_sec, cur_time);
 assert((quorum_duration > q_duration_required),
  "4) Same as (1), but an unrelated key result ends the day before target key begins");

 write_string("Finished");
}

function notary_parsing() {

  var pref_string_extra_notaries = "perspectives.additional_notary_list";
  var pref_string_use_def_notary = "perspectives.use_default_notary_list";
  var orig_extra_notaries = null;
  var orig_use_default_notaries = null;


  write_string("Starting notary parsing tests. <b>Note:</b> These tests require Perspectives to be installed.");


  // ask for permission to initialize data variables,
  // so calls to Perspectives.x properties work properly.
  // see README for details
  netscape.security.PrivilegeManager.enablePrivilege('UniversalXPConnect');
  Perspectives.init_data();


  // check if Perspectives is installed and we're able to read its preferences
  try {
    // save preferences so we can restore state afterward
    orig_extra_notaries = Perspectives.root_prefs.getCharPref(pref_string_extra_notaries);
    orig_use_default_notaries = Perspectives.root_prefs.getBoolPref(pref_string_use_def_notary);
  }
  catch (e) {
    write_string("<b>ERROR:</b> Perspectives must be installed to run these tests. Skipping notary parse tests.");
    g_test_count++;
    g_fail_count++;
    return;
  }

  if (orig_extra_notaries == null || orig_use_default_notaries == null) {
    write_string("<b>ERROR:</b> Could not read preferences from Perspectives plugin. Skipping notary parse tests.");
    g_test_count++;
    g_fail_count++;
    return;
  }


  // set preferences to known state so we can run our tests in a controlled env
  Perspectives.root_prefs.setCharPref(pref_string_extra_notaries, "");
  Perspectives.root_prefs.setBoolPref(pref_string_use_def_notary, true);

  var notaries = "";
  var initial_notary_count = 8; // Note: update if we change the default file

  notaries = Perspectives.getNotaryList();
  assert(notaries.length == initial_notary_count,
    "Default notary list gets us " + initial_notary_count + " notaries ");


  var nonsense_notary = "aaaaaaaa";
  Perspectives.root_prefs.setCharPref(pref_string_extra_notaries, nonsense_notary);
  notaries = Perspectives.getNotaryList();
  assert(notaries.length == initial_notary_count,
    "Trying to save a garbled notary string doesn't work.");



  // TODO bad method of declaration?
  // We need newlines after the server name and 'BEGIN PUBLIC KEY' lines
  // for the string to parse properly
  var notary_dupe = "perspectives1.networknotary.org:8080\n\
-----BEGIN PUBLIC KEY-----\n\
MIHKMA0GCSqGSIb3DQEBAQUAA4G4ADCBtAKBrAGXsegzE6E/6j4vgzi3NqGSn2dz\
W6gRxkuAL7PB8QmRqtG9ieSQjFB6cTYvkmp7x/LtHqlr9Fa6+/mT4Ma5oKU0RpgY\
MyfYnEk0iiNWG2fj4mRpTscHfcEJfKP13OGAYP1ZuHksTXSYsaKfIwiVKMLgQ/hA\
FHBSCs9X+bvVMgPOiEpxZXfaynOQ3TLGYtVywLRwW5yvlRq4E9z0rtvwR1bn1hVd\
JaJ2Lw7kRVMCAwEAAQ==\
-----END PUBLIC KEY-----";

  Perspectives.root_prefs.setCharPref(pref_string_extra_notaries, notary_dupe);
  notaries = Perspectives.getNotaryList();
  assert(notaries.length == initial_notary_count,
    "Trying to add a duplicate notary doesn't work.");
  //FIXME - note: this currently fails. We want to write code to prevent dupes.



  var sparse_notary = "perspectivesFAKETEST.networknotary.org:8080\n\n\n\n\
-----BEGIN PUBLIC KEY-----\n\n\n\n\n\
MIHKMA0GCSqGSIb3DQEBAQUAA4G4ADCBtAKBrAGXsegzE6E/6j4vgzi3NqGSn2dz\n\n\n\n\
W6gRxkuAL7PB8QmRqtG9ieSQjFB6cTYvkmp7x/LtHqlr9Fa6+/mT4Ma5oKU0RpgY\n\n\n\n\
MyfYnEk0iiNWG2fj4mRpTscHfcEJfKP13OGAYP1ZuHksTXSYsaKfIwiVKMLgQ/hA\n\n\n\n\
FHBSCs9X+bvVMgPOiEpxZXfaynOQ3TLGYtVywLRwW5yvlRq4E9z0rtvwR1bn1hVd\n\n\n\n\
JaJ2Lw7kRVMCAwEAAQ==\n\n\n\n\
-----END PUBLIC KEY-----\n\n\n\n";

  Perspectives.root_prefs.setCharPref(pref_string_extra_notaries, sparse_notary);
  notaries = Perspectives.getNotaryList();
  assert(notaries.length == (initial_notary_count + 1),
    "Trying to add a notary with many blank lines works.");



  // -------------
  // restore state once we're finished all of the tests
  Perspectives.root_prefs.setCharPref(pref_string_extra_notaries, orig_extra_notaries);
  Perspectives.root_prefs.setBoolPref(pref_string_use_def_notary, orig_use_default_notaries);

  write_string("Finished");
}


function run_tests() { 

  // print debug info to console by default
  Pers_debug.d_print_flags["error"] = true;
  
  try {
    clear();
    quorum_basics();
    quorum_oldkey();
    notary_parsing();


    write_string("Finished: " + g_pass_count + "/" + g_test_count + " successes, "
      + g_fail_count + " failures. ");
    if (g_test_count != (g_pass_count + g_fail_count)) {
      write_line("<b>ERROR:</b> Count totals did not match!");
    }
  } catch(e) { 
    alert(e);
    write_string("<b><font color='red'>ERROR</font></b> - tests did not finish: '" + e + "'.");
  } 
} 

</script>
</head>
<body>

<input type="button" value="Run Tests" onclick="run_tests()">
<p> Run with firebug to see detailed test output if something fails.  </p> 
<h2> Results: </h2>  
<div id="results"> 

</body>
</html>